import "./chunk-TCQZMY3T.js";

// node_modules/convertapi-js/dist/param.js
var Param = class {
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }
  get dto() {
    return Promise.resolve({
      Name: this.name,
      Value: this.value
    });
  }
};

// node_modules/convertapi-js/dist/file-param.js
var FileValue = class {
  constructor(name, fileId) {
    this.name = name;
    this.fileId = fileId;
  }
};
var FileParam = class {
  constructor(name, file, host) {
    this.name = name;
    this.file = file;
    this.host = host;
  }
  value() {
    if (this.file instanceof FileValue) {
      return Promise.resolve(this.file.fileId);
    } else {
      let uploadUrl = `https://${this.host}/upload?`;
      let response = this.file instanceof URL ? fetch(`${uploadUrl}url=${encodeURIComponent(this.file.href)}`, { method: "POST" }) : fetch(`${uploadUrl}filename=${encodeURIComponent(this.file.name)}`, { method: "POST", body: this.file });
      return response.then((r) => r.ok ? r.json() : Promise.reject({ Code: 5007, Message: `Unable to upload the file` })).then((obj) => obj.FileId);
    }
  }
  get dto() {
    return this.value().then((v) => ({
      Name: this.name,
      FileValue: { Id: v }
    }));
  }
};

// node_modules/convertapi-js/dist/files-param.js
var FilesValue = class {
  constructor(files) {
    this.files = files;
  }
  asArray() {
    return this.files.map((f) => new FileValue(f.FileName, f.FileId));
  }
};
var FilesParam = class {
  constructor(name, files, host) {
    this.name = name;
    this.fileValPros = [];
    if (files instanceof FileList) {
      this.fileValPros = Array.from(files).map((f) => new FileParam(name, f, host).value().then((i) => ({
        Id: i
      })));
    } else if (files instanceof FilesValue) {
      this.fileValPros = files.asArray().map((f) => Promise.resolve({
        Id: f.fileId
      }));
    } else {
      this.fileValPros = files.map((f) => Promise.resolve(f instanceof URL ? { Url: f.href } : { Id: f }));
    }
  }
  get dto() {
    return Promise.all(this.fileValPros).then((fv) => ({
      Name: this.name,
      FileValues: fv
    }));
  }
};

// node_modules/convertapi-js/dist/params.js
var Params = class {
  constructor(host, init) {
    this.host = host;
    this.params = [];
    let param;
    init == null ? void 0 : init.forEach((p) => {
      if (p.isFile) {
        if (typeof p.value === "string") {
          param = new FileParam(p.name, new FileValue("", p.value), this.host);
        } else {
          param = p.value instanceof Array ? new FilesParam(p.name, p.value, this.host) : param = new FileParam(p.name, p.value, this.host);
        }
      } else {
        param = new Param(p.name, p.value);
      }
      this.params.push(param);
    });
  }
  add(name, value) {
    let param;
    if (value instanceof FilesValue || value instanceof FileList || value instanceof Array) {
      param = new FilesParam(name, value, this.host);
    } else if (value instanceof FileValue || value instanceof File || value instanceof URL) {
      param = new FileParam(name, value, this.host);
    } else {
      param = new Param(name, value);
    }
    this.params.push(param);
    return param;
  }
  get(name) {
    return this.params.find((p) => p.name === name);
  }
  delete(name) {
    let idx = this.params.findIndex((p) => p.name === name);
    return this.params.splice(idx, 1)[0];
  }
  get dto() {
    let dtoPros = this.params.map((p) => p.dto);
    return Promise.all(dtoPros).then((ds) => ({ Parameters: ds }));
  }
};

// node_modules/convertapi-js/dist/result.js
var Result = class {
  constructor(dto) {
    this.dto = dto;
  }
  get duration() {
    return this.dto.ConversionCost;
  }
  get files() {
    return this.dto.Files;
  }
  toParamFile(idx = 0) {
    return new FileValue(this.dto.Files[idx].FileName, this.dto.Files[idx].FileId);
  }
  toParamFiles() {
    return new FilesValue(this.dto.Files);
  }
  uploadToS3(region, bucket, accessKeyId, secretAccessKey) {
    return this.dto.Files.map((f) => {
      let dto = {
        region,
        bucket,
        accessKeyId,
        secretAccessKey,
        fileId: f.FileId
      };
      return fetch(`https://integration.convertapi.com/s3/upload`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(dto)
      });
    });
  }
};

// node_modules/convertapi-js/dist/convertapi.js
var ConvertApi = class _ConvertApi {
  static auth(credentials, host) {
    return new _ConvertApi(credentials, host);
  }
  constructor(authCredentials, host = "v2.convertapi.com") {
    this.authCredentials = authCredentials;
    this.host = host;
  }
  createParams(init) {
    return new Params(this.host, init);
  }
  convert(fromFormat, toFormat, params) {
    return Promise.resolve(params.dto).then((dto) => {
      return fetch(`https://${this.host}/convert/${fromFormat}/to/${toFormat}?storefile=true`, {
        method: "POST",
        headers: {
          "content-type": "application/json",
          "authorization": `Bearer ${this.authCredentials}`
        },
        body: JSON.stringify(dto)
      }).then((r) => Promise.all([r.ok, r.json()])).then(([ok, o]) => ok ? o : Promise.reject(o)).then((dto2) => new Result(dto2));
    });
  }
};
export {
  ConvertApi as default
};
//# sourceMappingURL=convertapi-js.js.map
